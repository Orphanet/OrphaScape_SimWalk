
import os
import re
import sys
import subprocess
import path_variable as PV


def as_list(x, default):
    """Convertit en liste si nÃ©cessaire."""
    if x is None:
        return list(default)
    if isinstance(x, (list, tuple, set)):
        return list(x)
    return [str(x)]


def to_compact(v: str) -> str:
    """'1_1_1_1_1' -> '11111'"""
    return v.replace("_", "")


def s(p) -> str:
    """Convertit Path en string."""
    return str(p)


def _parse_mode_cfg(mcfg: dict):
    """Extrait combine/sm/vecs depuis une section dd: ou dp:."""
    combine  = as_list(mcfg.get("combine"), [])
    sm       = as_list(mcfg.get("sm_method"), [])
    vecs_raw = as_list(mcfg.get("vector_strs") or mcfg.get("vector_str"), [])
    vecs     = [to_compact(v) for v in vecs_raw]
    return combine, sm, vecs


def _wc(lst):
    """Wildcard constraint : jamais satisfait si liste vide."""
    return "|".join(map(re.escape, lst)) if lst else "DISABLED"


# =============================================================================
# CONFIGURATION
# =============================================================================

cfg          = config
product4     = cfg.get("product4")
mini_rd      = cfg.get("mini_rd", "")
mini_patient = cfg.get("mini_patient", "")
do_subsumed  = cfg.get("do_subsumed", 0)

# Sections dd: et dp:
dd_cfg = cfg.get("dd", {})
dp_cfg = cfg.get("dp", {})

dd_combine, dd_sm, dd_vecs = _parse_mode_cfg(dd_cfg) if dd_cfg else ([], [], [])
dp_combine, dp_sm, dp_vecs = _parse_mode_cfg(dp_cfg) if dp_cfg else ([], [], [])

OUT_DD = s(PV.PATH_OUTPUT_DD)
OUT_DP = s(PV.get_dp_path(do_subsumed))

# =============================================================================
# RULES
# =============================================================================

rule all:
    input:
        expand(os.path.join(OUT_DD, "{cdd}_{sdd}_" + product4 + "_{vdd}.parquet"),
               cdd=dd_combine, sdd=dd_sm, vdd=dd_vecs),
        expand(os.path.join(OUT_DP, "{cdp}_{sdp}_" + product4 + "_{vdp}.parquet"),
               cdp=dp_combine, sdp=dp_sm, vdp=dp_vecs)


### DD

rule run_combo_dd:
    input:
        s(PV.PATH_YAML_PRODUCT4)
    output:
        directory(os.path.join(OUT_DD, "{cdd}", "{sdd}", product4, "{vdd}"))
    wildcard_constraints:
        vdd=r"[0-9]{5}",
        cdd=_wc(dd_combine),
        sdd=_wc(dd_sm)
    run:
        print(f"Computing DD {wildcards.cdd}/{wildcards.sdd}/{wildcards.vdd}")
        cmd = [
            sys.executable, "-m", "bin.main_sm", "dd",
            "--combine", wildcards.cdd,
            "--sm", wildcards.sdd,
            "--vector-str", wildcards.vdd,
            "--pd4", product4,
            "--mini-rd", mini_rd,
        ]
        subprocess.check_call(cmd)

rule aggregate_dd:
    input:
        os.path.join(OUT_DD, "{cdd}", "{sdd}", product4, "{vdd}")
    output:
        os.path.join(OUT_DD, "{cdd}_{sdd}_" + product4 + "_{vdd}.parquet")
    wildcard_constraints:
        vdd=r"[0-9]{5}",
        cdd=_wc(dd_combine),
        sdd=_wc(dd_sm)
    run:
        subprocess.check_call([
            sys.executable, "-m", "bin.main_concat", "concat_dd",
            "--vector-str", wildcards.vdd,
            "--col1", "OC1", "--col2", "OC2",
            "--pd4", product4,
            "--combine", wildcards.cdd,
            "--sm", wildcards.sdd,
        ])


### DP

rule run_combo_dp:
    input:
        s(PV.PATH_YAML_PRODUCT4)
    output:
        directory(os.path.join(OUT_DP, "{cdp}", "{sdp}", product4, "{vdp}"))
    wildcard_constraints:
        vdp=r"[0-9]{5}",
        cdp=_wc(dp_combine),
        sdp=_wc(dp_sm)
    run:
        print(f"Computing DP {wildcards.cdp}/{wildcards.sdp}/{wildcards.vdp}")
        cmd = [
            sys.executable, "-m", "bin.main_sm", "dp",
            "--combine", wildcards.cdp,
            "--sm", wildcards.sdp,
            "--vector-str", wildcards.vdp,
            "--pd4", product4,
            "--mini-rd", mini_rd,
            "--do-subsumed", str(do_subsumed),
        ]
        if mini_patient:
            cmd += ["--mini-patient", mini_patient]
        subprocess.check_call(cmd)

rule aggregate_dp:
    input:
        os.path.join(OUT_DP, "{cdp}", "{sdp}", product4, "{vdp}")
    output:
        os.path.join(OUT_DP, "{cdp}_{sdp}_" + product4 + "_{vdp}.parquet")
    wildcard_constraints:
        vdp=r"[0-9]{5}",
        cdp=_wc(dp_combine),
        sdp=_wc(dp_sm)
    run:
        subprocess.check_call([
            sys.executable, "-m", "bin.main_concat", "concat_dp",
            "--vector-str", wildcards.vdp,
            "--col1", "patients", "--col2", "RDs",
            "--pd4", product4,
            "--combine", wildcards.cdp,
            "--sm", wildcards.sdp,
            "--do-subsumed", str(do_subsumed),
        ])
