# Snakefile.sim 
"""
Snakefile pour le calcul MM/MP et concaténation.
Usage:
  snakemake -s Snakefile.sim --configfile config_sm_mm.yaml --cores all
  snakemake -s Snakefile.sim --configfile config_sm_mp.yaml --cores all
"""
import os
import re
import path_variable as PV

# =============================================================================
# HELPERS
# =============================================================================

def as_list(x, default):
    """Convertit en liste si nécessaire."""
    if x is None:
        return list(default)
    if isinstance(x, (list, tuple, set)):
        return list(x)
    return [str(x)]


def to_compact(v: str) -> str:
    """'1_1_1_1_1' -> '11111'"""
    return v.replace("_", "")


def s(p) -> str:
    """Convertit Path en string."""
    return str(p)

# =============================================================================
# CONFIGURATION
# =============================================================================

# get value config 
cfg = config

# "mm" valeur par defaut du dict a la clé "mode" si non specificé
mode = cfg.get("mode", "mm")
mini_rd = cfg.get("mini_rd", "")
mini_patient = cfg.get("mini_patient", "")
product4 = cfg.get("product4")

combine_list = as_list(cfg.get("combine"), ["funSimMax"])
sm_list = as_list(cfg.get("sm_method"), ["resnik"])

# Vecteurs
# Vecteurs - gérer les deux cas (singulier et pluriel)
vecs_cfg = cfg.get("vector_strs") or cfg.get("vector_str")
if vecs_cfg:
    selected_vectors_raw = as_list(vecs_cfg, ["1_1_1_1_1"])
else:
    selected_vectors_raw = ["1_1_1_1_1"]
selected_vectors_compact = [to_compact(v) for v in selected_vectors_raw]

# Répertoire de sortie
OUT_BASE = s(PV.PATH_OUTPUT_MM) if mode == "mm" else s(PV.PATH_OUTPUT_SM)


# Choix selon mode
AGG_CMD = "concat_mm" if mode == "mm" else "concat_mp"
COL1 = "OC1" if mode == "mm" else "patients"
COL2 = "OC2" if mode == "mm" else "RDs"

# Option patients (MP only)
MP_EXTRA = f'--mini-patient "{mini_patient}"' if mode == "mp" and mini_patient else ""

# =============================================================================
# PATTERNS
# =============================================================================

def vec_dir_pattern():
    return os.path.join(OUT_BASE, "{combine}", "{sm}", product4, "{vector_str}")


def agg_file_pattern():
    return os.path.join(OUT_BASE, "{combine}_{sm}_" + product4 + "_{vector_str}.parquet")

# =============================================================================
# RULES
# =============================================================================

rule all:
    input:
        # load all possible combinaison depending on the list of config para 
        expand(agg_file_pattern(),
               combine=combine_list, sm=sm_list, vector_str=selected_vectors_compact)





rule run_combo:
    input:
        s(PV.PATH_YAML_PRODUCT4)
    output:
        directory(vec_dir_pattern())
    wildcard_constraints:
        # stricly equal to len 5
        vector_str=r"[0-9]{5}",
        combine="|".join(map(re.escape, combine_list)),
        sm="|".join(map(re.escape, sm_list))
    shell:
        r"""
        set -euo pipefail
        echo "Computing {wildcards.combine}/{wildcards.sm}/{wildcards.vector_str}"
        python -m bin.main_sm {mode}  \
        --combine {wildcards.combine}  \
        --sm {wildcards.sm}    \
        --vector-str {wildcards.vector_str} \
        --pd4 {product4} \
        --mini-rd "{mini_rd}" {MP_EXTRA}
        """


rule aggregate_sm:
    input:
        vec_dir_pattern()
    output:
        agg_file_pattern()
    wildcard_constraints:
        vector_str=r"[0-9]{5}",
        combine="|".join(map(re.escape, combine_list)),
        sm="|".join(map(re.escape, sm_list))
    shell:
        r"""
        python -m bin.main_concat {AGG_CMD} \
          --vector-str {wildcards.vector_str} \
          --col1 {COL1} \
          --col2 {COL2} \
          --pd4 {product4} \
          --combine {wildcards.combine}  \
          --sm {wildcards.sm} 
        """
 
